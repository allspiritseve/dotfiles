#!/bin/bash

if [ ! -d ./.git ]; then
  echo "Couldn't find git repo... are you in the right directory?"
  exit 1
fi

case "$1" in
  production) environment=production; shift;;
  staging) environment=staging; shift;;
  *) environment=staging;;
esac

if [ -f ./.beornrc ]; then
  source ./.beornrc
fi

platform=${platform-'custom'}
remote=${remote-$environment}
user=${user-'web'}
commands=()

# Helpers

while getopts t opt; do
  case $opt in
    t) autotag=true;;
  esac
done

init_heroku() {
  if [ -z "$app" ]; then
    echo "Can't determine Heroku application name. Please add it to .beornrc"
    exit 1
  fi

  beorn_exec() {
    echo_exec "heroku $@ --app $app"
  }

  deploy() {
    confirm_deploy "Deploy latest commit to Heroku $remote?"
    echo_exec "git push $remote master" && run "rake db:migrate"
  }

  redeploy() {
    confirm_deploy "Redeploy latest commit to Heroku $remote?"

    echo "Ok, redeploying latest commit to Heroku $remote!"

    echo_exec "git push -f $remote master" && run "rake db:migrate"
  }

  run() {
    beorn_exec run $@
  }

  status() {
    echo "This is a Heroku app."
  }

  logs() {
    heroku_cmd logs
  }  

  tag_release() {
    echo "No need to tag releases, as you're using Heroku" >&2
    exit 1
  }

  heroku_cmd() {
    echo_exec "heroku $@ --app $app"
  }

  commands=(${commands[@]} config:add config:remove deploy logs redeploy run config status)
}

init_deis() {
  if [ -z "$app" ]; then
    echo "Can't determine Deis application name. Please add it to .beornrc"
    exit 1
  fi

  beorn_exec() {
    echo_exec "deis $@ --app $app"
  }

  deploy() {
    confirm_deploy "Deploy latest commit to Deis $remote?"
    echo_exec "git push $remote master" && run "rake db:migrate"
  }

  redeploy() {
    confirm_deploy "Redeploy latest commit to Deis $remote?"

    echo "Ok, redeploying latest commit to Deis $remote!"

    echo_exec "git push -f $remote master" && run "rake db:migrate"
  }

  run() {
    beorn_exec run $@
  }

  logs() {
    beorn_exec logs
  }

  commands=(${commands[@]} deploy redeploy run logs)
}

init_custom() {
  beorn_exec() {
    $@
  }

  deploy() {
    tag=$(current_tag)
    branch=$(branch)

    confirm_deploy "Deploy release $tag to $remote?"

    echo "Ok, deploying release $tag to $remote!"

    git push $remote $tag
    git push origin $branch $tag
  }

  redeploy() {
    tag=$(current_tag)

    confirm_deploy "Redeploy" $tag

    echo "Ok, redeploying release $tag to $remote!"
    git push -f $remote $tag
  }

  run() {
    ssh -t $user@$host run $@
  }

  status() {
    tag=$(current_tag)
    current_branch=$(branch)


    set -- $(git rev-list --left-right --count $tag...HEAD)
    
    echo "Current branch: $current_branch"
    echo "Current tag $tag"
    echo "Your branch is ahead $2 commits and behind $1 commits"
    echo "  (use beorn tag to create another release)"
  }

  tag_release() {
    tag=$(next_tag)
    git tag $tag
    git push origin $tag
    echo "Ok, tagged release $tag."
  }

  logs() {
    echo_exec ssh $user@$host tail $@ /home/web/app/current/log/$environment.log
  }

  commands=(${commands[@]} deploy logs redeploy run status tag_release)
}

confirm_deploy() {
  read -p "${1-"Deploy release $tag to $remote?"} (y/n) " deploy

  if [[ "$deploy" != "y" ]]; then
    echo "Deploy cancelled!"
    exit 1
  fi
}

# Commands
bash() {
  ssh $host
}

branch() {
  [[ `git status | head -n 1` =~ On\ branch\ (.*) ]] && echo ${BASH_REMATCH[1]}
}

commands() {
  for cmd in "${commands[@]}"; do
    echo $cmd
  done | sort -du
}

completions() {
  echo ""
}

current_tag() {
  git tag -l --sort="v:refname" | tail -n 1
}

migrate() {
  bundle exec rake db:migrate db:rollback && bundle exec rake db:migrate
}

next_tag() {
  timestamp=`date +%Y%m%d`
  count=`git tag -l "$timestamp-*" | wc -l`
  echo $timestamp-`expr $count + 1`
}

retag() {
  # git commit --amend --no-edit

  tag=$(current_tag)

  git tag -d $tag
  git tag $tag
  git push -f origin $tag

  echo "Ok, retagged release $tag."
}

sync() {
  git fetch
  git push
}

test() {
  if [[ "$@" =~ ^spec/ ]]; then
    eval "rspec $@"
  else
    echo_exec ruby -I'lib:test' $@
  fi
}

commands=(${commands[@]} bash branch commands console current_tag migrate next_tag rake retag retag_deploy status sync tag tag_deploy test)

# Internal

beorn_echo() {
  echo " -> $@"
}

beorn_join() {
  local IFS="$1"; shift; echo "$*";
}

echo_exec() {
  beorn_echo $@
  $@
}

checkpoint() {
  if [ -z "$1" ]; then
    echo -e "Please pass a checkpoint name, e.g. beorn checkpoint my-changes"
    exit 1
  fi
  echo "beorn checkpoint $1"
  timestamp=`date +%Y-%m-%d %H:%M:%S`
  git checkout -b $1
  git add .
  git commit -m "Checkpoint $timestamp"
  git checkout master
}

init_${platform}

case "$1" in
  b) bash ${@:2};;
  deis) beorn_exec ${@:2};;
  c|console) run rails console;;
  config|config:set|config:remove) beorn_exec $@;;
  d) deploy ${@:2};;
  heroku) heroku_cmd ${@:2};;
  rake) run $@;;
  tag) tag_release;;
  tag_deploy) tag_release && deploy;;
  reload) run reload;;
  retag_and_deploy) retag && redeploy;;
  r) run ${@:2};;
  u|update)
    ssh $host 'sudo apt-get update && sudo apt-get upgrade'
    ;;
  *)
    for cmd in "${commands[@]}"; do
      [[ "$1" == $cmd ]] && $@ && exit 0
    done

    echo -e "Received: $@" >&2
    echo -e "\nDid not recognize command '$1'\n\nUsage: beorn ($(beorn_join '|' ${commands[@]}))" >&2
    exit 1
    ;;
esac
